# 4 概述

本节包含ECMAScript语言的非规范性概述。

ECMAScript是一种面向对象的编程语言，用于在宿主环境中执行计算和操作计算对象。这里定义的ECMAScript并不是自己给自己定下计算规则；实际上，本规范中没有关于外部数据输入或计算结果输出的规定。相反，ECMAScript程序的计算环境将不仅提供本规范中描述的对象和其他工具，还将提供特定于环境的对象，它们的描述和行为超出了本规范的范围，除非表明它们可能提供可访问的某些属性和可从ECMAScript程序调用的某些函数。

ECMAScript最初被设计用来作为一种脚本语言，但现在已经被广泛用作一种通用编程语言。脚本语言是一种用于操作、自定义和自动化现有系统的程序语言。在这样的系统中，通过用户接口我们能获得很多有用的功能，而脚本语言是一种向程序控制公开该功能的机制。这样，现有的系统就可以提供一个包含对象和设施的宿主环境，这就完成了脚本语言的功能。脚本语言可供专业和非专业程序员使用。

ECMAScript最初被设计成一种Web脚本语言，它提供了一种机制来激活浏览器中的Web页面并作为基于Web的客户机-服务器体系结构的一部分来执行服务器计算。ECMAScript现在用于为各种主机环境提供核心脚本功能。因此，除了任何特定的主机环境外，本文档指定了核心语言。

ECMAScript的使用已经超越了简单的脚本编写，现在已用于许多不同环境和规模的各种编程任务。 随着ECMAScript用途的扩展，它提供的功能和特性也随之增加。 ECMAScript现在是一种功能全面的通用编程语言。

ECMAScript的一些功能与其他编程语言中使用的类似，特别是C、Java™，Self和Scheme，如中所述：

ISO/IEC 9899:1996, Programming Languages — C.

Gosling, James, Bill Joy and Guy Steele. The Java™ Language Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. OOPSLA '87 Conference Proceedings, pp. 227-241, Orlando, FL, October 1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


## 4.1 web脚本

web浏览器为客户端计算提供ECMAScript宿主环境，例如，包括表示窗口、菜单、弹出窗口、对话框、文本区域、锚点、frame、history、cookies和输入/输出的对象。此外，主机环境还提供了一种将脚本代码附加到事件的方法，如焦点更改、页面和图像加载、卸载、错误和中止、选择区域、表单提交和鼠标操作。脚本代码出现在HTML中，显示的页面是用户界面元素、固定和计算的文本和图像的组合。脚本代码对用户交互进行反应，不需要主程序。

web服务器为服务器端计算提供了不同的宿主环境，包括表示请求、客户端和文件的对象，以及锁定和共享数据的机制。通过同时使用浏览器端和服务器端脚本，可以在客户端和服务器端之间分配计算，同时为基于Web的应用程序提供自定义的用户界面。

每个支持ECMAScript的Web浏览器和服务器都提供自己的宿主环境，从而完成ECMAScript的执行环境。

## 4.2主机和实现

为了帮助将ECMAScript集成到主机环境中，本规范将某些功能（例如抽象操作）的定义全部或部分地推迟到本规范之外的源代码。在编辑上，本规范区分了以下几种延期。

实施是一种外部来源，它进一步定义了附件D中列举的设施，或那些被标记为实施定义或近似实现的设施。在非正式使用中，实现指的是具体的人工制做的产品，例如特定的web浏览器。

实现定义的设施是指在没有进一步限定的情况下将其定义推迟到外部来源的设施。本规范不对特定行为提出任何建议，一致性实施可在本规范提出的限制条件内自由选择任何行为。

近似实现的设施是指在推荐理想行为的同时，将其定义推迟到外部来源。虽然一致性实现可以在本规范提出的限制条件内自由选择任何行为，但鼓励它们努力接近理想。一些数学运算，如数学实验，是实现的近似值。

主机是一个外部来源，它进一步定义了附录D中列出的设施，但没有进一步定义其他实施定义或近似实现的设施。在非正式使用中，主机是指所有实现的集合，例如所有web浏览器的集合，它们通过附件D以相同的方式与此规范交互。主机通常是外部规范，例如WHATWG HTML(https://html.spec.whatwg.org/). 换句话说，由主机定义的设施通常在外部规范中进一步定义。

主机hook是由外部源全部或部分定义的抽象操作。 所有主机hook必须列在附件 D 中。主机挂钩必须至少符合以下要求：

- 它必须返回正常完成或抛出完成。

主机定义的设施是指在没有进一步限定的情况下将其定义推迟到外部来源的设施，并在附录D中列出。非主机的实现也可以为主机定义的设施提供定义。

主机环境是所有主机定义设施的特定定义选择。宿主环境通常包括对象或函数，这些对象或函数允许获取输入并将输出作为全局对象的主机定义属性提供。

本规范遵循始终使用最具体术语的编辑惯例。例如，如果设施是主机定义的，则不应将其称为实现定义的。

主机和实现都可以通过本文定义的语言类型、规范类型、抽象操作、语法生成、内在对象和内在符号与本规范接口。


## 4.3 ECMA概述

ECMAScript概述下面是对ECMAScript的非正式概述，并没有描述语言的所有部分。此概述不是标准的一部分。

ECMAScript是基于对象的：基本语言和主机设施由对象提供，ECMAScript程序是通信对象的集群。在ECMAScript中，对象是零个或多个属性的集合，每个属性都有确定如何使用每个属性的属性。例如，当属性的可写属性设置为false时，执行的ECMAScript代码为属性分配不同值的任何尝试都会失败。属性是包含其他对象、原始值或函数的容器。原始值是以下内置类型之一的成员：Undefined、Null、Boolean、Number、BigInt、String和Symbol；对象是内置类型对象的成员；函数是可调用对象。通过属性与对象关联的函数称为方法。

ECMAScript定义了一个内置对象的集合，这些对象构成了ECMAScript实体的定义。这些内置对象包括全局对象,以及语言的运行时语义对象，包括Object, Function, Boolean, Symbol,不同的Error对象；表示和操作数值（Math, Number，Date）的对象；文本处理对象String和RegExp；对象是值的索引集合，包括数组和九种不同类型化数组（Int8Array，Uint8Array，Int16Array等等，它们的元素都具有特定的数值数据表示；有键值的集合Map和Set；支持结构化数据的对象，包括JSON、ArrayBuffer、SharedArrayBuffer和DataView；支持控制抽象的对象，包括generator函数和Promise对象；以及反射对象，包括Proxy和Reflect。

ECMAScript还定义了一组内置运算符。ECMAScript运算符包括各种一元运算符、乘法运算符、加法运算符、按位移位运算符、关系运算符、相等运算符、二进制位运算符、二进制逻辑运算符、赋值运算符和逗号运算符。

大型ECMAScript程序由模块支持，这些模块允许将程序划分为多个语句和声明序列。每个模块都显式地标识它所使用的需要由其他模块提供的声明，以及它的哪些声明可供其他模块使用。

ECMAScript语法有意类似于Java语法。ECMAScript语法被放宽，使其能够作为一种易于使用的脚本语言。例如，变量不需要声明其类型，也不需要将类型与属性关联，并且定义的函数不需要在调用它们之前以文本方式显示它们的声明。

### 4.3.1对象

尽管ECMAScript包含类定义的语法，ECMAScript对象也不是根本上的类，比如C++、SimalTalk或java中的那些。相反，可以用各种方式创建对象，包括通过字面量或通过构造函数创建对象，然后通过为对象的属性指定初始值来执行初始化全部或部分对象的代码。每个构造函数都是一个函数，它有一个名为“prototype”的属性，用于实现基于原型的继承和共享属性。对象通过构造函数在new表达式中创建；例如，new Date（2009，11）创建了一个新的日期对象。不使用new调用构造函数的结果取决于构造函数。例如，Date（）生成当前日期和时间的字符串表示形式，而不是对象。

构造函数创建的每个对象都有一个隐式引用（称为对象的原型）到其构造函数的“prototype”属性的值。此外，一个原型可能对它的原型有一个非null的隐式引用，以此类推；这称为原型链。当引用对象中的属性时，该引用是原型链中包含该名称属性的第一个对象中该名称的属性。换言之，首先检查直接提到的对象是否具有这样的属性；如果该对象包含命名属性，即引用这个属性；如果该对象不包含命名属性，则接下来检查该对象的原型，依此类推。

在基于类的面向对象语言中，一般情况下，状态由实例承载，方法由类承载，而继承仅限于结构和行为。在ECMAScript中，状态和方法由对象携带，而结构、行为和状态都是继承的。

所有不直接包含其原型包含的特定属性的对象都共享该属性及其值。

与大多数基于类的对象语言不同，属性可以通过给对象赋值来动态地添加到对象中。也就是说，构造函数不需要为构造对象的所有或任何属性命名或赋值。

尽管ECMAScript对象本质上不是基于类的，但是基于构造函数函数、原型对象和方法的公共模式来定义类抽象通常是很方便的。ECMAScript内置对象本身遵循这样的类模式。从ECMAScript 2015开始，ECMAScript语言包含语法类定义，允许程序员简洁地定义符合内置对象所使用的类抽象模式的对象。

### 4.3.2严格变体

ECMAScript语言认识到这种可能性，即该语言的某些用户可能希望限制他们对该语言中某些可用特性的使用。他们这样做可能是为了安全起见，为了避免他们认为容易出错的特性，为了得到增强的错误检查，或者出于他们选择的其他原因。为了支持这种可能性，ECMAScript定义了一个语言的严格变体。该语言的严格变体排除了常规ECMAScript语言的一些特定的语法和语义特征，并修改了一些特征的详细语义。严格变体也指定了额外的错误条件，它们必须通过抛出错误异常来报告，在语言的非严格模式下是没有指定的这些错误的。

ECMAScript的严格变体通常被称为语言的严格模式。严格模式选择和ECMAScript的严格模式语法和语义的使用是在单个ECMAScript源文本为单位显式进行的，如10.2.2所述。因为严格模式是在一个语法源文本单元的层次上选择的，所以严格模式只对这种源文本单元施加具有局部效应的限制。严格模式不限制或修改ECMAScript语义的任何方面，语义必须在多个源文本之间都是一致的。一个完整的ECMAScript程序可以由严格模式和非严格模式ECMAScript源文本单元组成。在这种情况下，严格模式只适用于实际执行在严格模式源文本单元中定义的代码。

为了符合此规范，ECMAScript实现必须实现完全不受限制的ECMAScript语言和本规范定义的ECMAScript语言的严格变体。此外，实现必须支持将无限制和严格模式的源文本单元组合到单个复合程序中。