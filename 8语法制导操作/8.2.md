
## 8.3 Labels

### 8.2.1 Static Semantics: ContainsDuplicateLabels(包含两个标签)

语法制导的操作 ContainsDuplicateLabels 采用参数 labelSet。 它在以下产生式上分段定义：

Statement :
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block :
{ }
StatementListItem :
Declaration
1. Return false.
StatementList : StatementList StatementListItem
1. Let hasDuplicates be ContainsDuplicateLabels of StatementList with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of StatementListItem with argument labelSet.
IfStatement : if ( Expression ) Statement else Statement
1. Let hasDuplicate be ContainsDuplicateLabels of the first Statement with argument labelSet.
2. If hasDuplicate is true, return true.
3. Return ContainsDuplicateLabels of the second Statement with argument labelSet.
IfStatement : if ( Expression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
DoWhileStatement : do Statement while ( Expression ) ;
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
WhileStatement : while ( Expression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
ForStatement :
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
ForInOfStatement :
for ( LeftHandSideExpression in Expression ) Statement
for ( var ForBinding in Expression ) Statement
for ( ForDeclaration in Expression ) Statement
for ( LeftHandSideExpression of AssignmentExpression ) Statement
for ( var ForBinding of AssignmentExpression ) Statement
for ( ForDeclaration of AssignmentExpression ) Statement
for await ( LeftHandSideExpression of AssignmentExpression ) Statement
for await ( var ForBinding of AssignmentExpression ) Statement
for await ( ForDeclaration of AssignmentExpression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.

>NOTE 本节由附录B.3.5扩展。

WithStatement : with ( Expression ) Statement
1. Return ContainsDuplicateLabels of Statement with argument labelSet.
SwitchStatement : switch ( Expression ) CaseBlock
1. Return ContainsDuplicateLabels of CaseBlock with argument labelSet.
CaseBlock : { }
1. Return false.
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
1. If the first CaseClauses is present, then
a. If ContainsDuplicateLabels of the first CaseClauses with argument labelSet is true, return true.
2. If ContainsDuplicateLabels of DefaultClause with argument labelSet is true, return true.
3. If the second CaseClauses is not present, return false.
4. Return ContainsDuplicateLabels of the second CaseClauses with argument labelSet.
CaseClauses : CaseClauses CaseClause
1. Let hasDuplicates be ContainsDuplicateLabels of CaseClauses with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of CaseClause with argument labelSet.
CaseClause : case Expression : StatementListopt
1. If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.
2. Return false.
DefaultClause : default : StatementListopt
1. If the StatementList is present, return ContainsDuplicateLabels of StatementList with argument labelSet.
2. Return false.
LabelledStatement : LabelIdentifier : LabelledItem
1. Let label be the StringValue of LabelIdentifier.
2. If label is an element of labelSet, return true.
3. Let newLabelSet be the list-concatenation of labelSet and « label ».
4. Return ContainsDuplicateLabels of LabelledItem with argument newLabelSet.
LabelledItem : FunctionDeclaration
1. Return false.
TryStatement : try Block Catch
1. Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of Catch with argument labelSet.
TryStatement : try Block Finally
1. Let hasDuplicates be ContainsDuplicateLabels of Block with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of Finally with argument labelSet.
TryStatement : try Block Catch Finally
1. If ContainsDuplicateLabels of Block with argument labelSet is true, return true.
2. If ContainsDuplicateLabels of Catch with argument labelSet is true, return true.
3. Return ContainsDuplicateLabels of Finally with argument labelSet.
Catch : catch ( CatchParameter ) Block
1. Return ContainsDuplicateLabels of Block with argument labelSet.
FunctionStatementList : [empty]
1. Return false.
ClassStaticBlockStatementList : [empty]
1. Return false.
ModuleItemList : ModuleItemList ModuleItem
1. Let hasDuplicates be ContainsDuplicateLabels of ModuleItemList with argument labelSet.
2. If hasDuplicates is true, return true.
3. Return ContainsDuplicateLabels of ModuleItem with argument labelSet.
ModuleItem :
ImportDeclaration
ExportDeclaratio
1. Return false.

### 8.2.2 Static Semantics: ContainsUndefinedBreakTarget

语法制导的操作 ContainsUndefinedBreakTarget 采用参数 labelSet。 它在以下产生式上分段定义：

Statement :
VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block :
{ }
StatementListItem :
Declaration
1. Return false.
StatementList : StatementList StatementListItem
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of StatementList with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of StatementListItem with argument labelSet.
IfStatement : if ( Expression ) Statement else Statement
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the first Statement with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of the second Statement with argument labelSet.
IfStatement : if ( Expression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
DoWhileStatement : do Statement while ( Expression ) ;
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
WhileStatement : while ( Expression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
ForStatement :
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
ForInOfStatement :
for ( LeftHandSideExpression in Expression ) Statement
for ( var ForBinding in Expression ) Statement
for ( ForDeclaration in Expression ) Statement
for ( LeftHandSideExpression of AssignmentExpression ) Statement
for ( var ForBinding of AssignmentExpression ) Statement
for ( ForDeclaration of AssignmentExpression ) Statement
for await ( LeftHandSideExpression of AssignmentExpression ) Statement
for await ( var ForBinding of AssignmentExpression ) Statement
for await ( ForDeclaration of AssignmentExpression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.

>NOTE 本节由附录B.3.5扩展。

BreakStatement : break ;
1. Return false.
BreakStatement : break LabelIdentifier ;
1. If the StringValue of LabelIdentifier is not an element of labelSet, return true.
2. Return false.
WithStatement : with ( Expression ) Statement
1. Return ContainsUndefinedBreakTarget of Statement with argument labelSet.
SwitchStatement : switch ( Expression ) CaseBlock
1. Return ContainsUndefinedBreakTarget of CaseBlock with argument labelSet.
CaseBlock : { }
1. Return false.
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
1. If the first CaseClauses is present, then
a. If ContainsUndefinedBreakTarget of the first CaseClauses with argument labelSet is true, return true.
2. If ContainsUndefinedBreakTarget of DefaultClause with argument labelSet is true, return true.
3. If the second CaseClauses is not present, return false.
4. Return ContainsUndefinedBreakTarget of the second CaseClauses with argument labelSet.
CaseClauses : CaseClauses CaseClause
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of CaseClauses with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of CaseClause with argument labelSet.
CaseClause : case Expression : StatementListopt
1. If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument labelSet.
2. Return false.
DefaultClause : default : StatementListopt
1. If the StatementList is present, return ContainsUndefinedBreakTarget of StatementList with argument labelSet.
2. Return false.
LabelledStatement : LabelIdentifier : LabelledItem
1. Let label be the StringValue of LabelIdentifier.
2. Let newLabelSet be the list-concatenation of labelSet and « label ».
3. Return ContainsUndefinedBreakTarget of LabelledItem with argument newLabelSet.
LabelledItem : FunctionDeclaration
1. Return false.
TryStatement : try Block Catch
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of Catch with argument labelSet.
TryStatement : try Block Finally
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of Finally with argument labelSet.
TryStatement : try Block Catch Finally
1. If ContainsUndefinedBreakTarget of Block with argument labelSet is true, return true.
2. If ContainsUndefinedBreakTarget of Catch with argument labelSet is true, return true.
3. Return ContainsUndefinedBreakTarget of Finally with argument labelSet.
Catch : catch ( CatchParameter ) Block
1. Return ContainsUndefinedBreakTarget of Block with argument labelSet.
FunctionStatementList : [empty]
1. Return false.
ClassStaticBlockStatementList : [empty]
1. Return false.
ModuleItemList : ModuleItemList ModuleItem
1. Let hasUndefinedLabels be ContainsUndefinedBreakTarget of ModuleItemList with argument labelSet.
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedBreakTarget of ModuleItem with argument labelSet.
ModuleItem :
ImportDeclaration
ExportDeclaration
1. Return false.

### 8.2.3 Static Semantics: ContainsUndefinedContinueTarget

语法制导的操作 ContainsUndefinedContinueTarget 采用参数迭代集和标签集。 它在以下产生式上分段定义：

Statement :
VariableStatement
EmptyStatement
ExpressionStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement
Block :
{ }
StatementListItem :
Declaration
1. Return false.
Statement : BlockStatement
1. Return ContainsUndefinedContinueTarget of BlockStatement with arguments iterationSet and « ».
BreakableStatement : IterationStatement
1. Let newIterationSet be the list-concatenation of iterationSet and labelSet.
2. Return ContainsUndefinedContinueTarget of IterationStatement with arguments newIterationSet and « ».
StatementList : StatementList StatementListItem
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of StatementListItem with arguments iterationSet and « ».
IfStatement : if ( Expression ) Statement else Statement
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the first Statement with arguments iterationSet and « ».
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of the second Statement with arguments iterationSet and « ».
IfStatement : if ( Expression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
DoWhileStatement : do Statement while ( Expression ) ;
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
WhileStatement : while ( Expression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
ForStatement :
for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
ForInOfStatement :
for ( LeftHandSideExpression in Expression ) Statement
for ( var ForBinding in Expression ) Statement
for ( ForDeclaration in Expression ) Statement
for ( LeftHandSideExpression of AssignmentExpression ) Statement
for ( var ForBinding of AssignmentExpression ) Statement
for ( ForDeclaration of AssignmentExpression ) Statement
for await ( LeftHandSideExpression of AssignmentExpression ) Statement
for await ( var ForBinding of AssignmentExpression ) Statement
for await ( ForDeclaration of AssignmentExpression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».

>NOTE 本节由附录B.3.5扩展。

ContinueStatement : continue ;
1. Return false.
ContinueStatement : continue LabelIdentifier ;
1. If the StringValue of LabelIdentifier is not an element of iterationSet, return true.
2. Return false.
WithStatement : with ( Expression ) Statement
1. Return ContainsUndefinedContinueTarget of Statement with arguments iterationSet and « ».
SwitchStatement : switch ( Expression ) CaseBlock
1. Return ContainsUndefinedContinueTarget of CaseBlock with arguments iterationSet and « ».
CaseBlock : { }
1. Return false.
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
1. If the first CaseClauses is present, then
a. If ContainsUndefinedContinueTarget of the first CaseClauses with arguments iterationSet and « » is true, return true.
2. If ContainsUndefinedContinueTarget of DefaultClause with arguments iterationSet and « » is true, return true.
3. If the second CaseClauses is not present, return false.
4. Return ContainsUndefinedContinueTarget of the second CaseClauses with arguments iterationSet and « ».
CaseClauses : CaseClauses CaseClause
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of CaseClauses with arguments iterationSet and « ».
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of CaseClause with arguments iterationSet and « ».
CaseClause : case Expression : StatementListopt
1. If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».
2. Return false.
DefaultClause : default : StatementListopt
1. If the StatementList is present, return ContainsUndefinedContinueTarget of StatementList with arguments iterationSet and « ».
2. Return false.
LabelledStatement : LabelIdentifier : LabelledItem
1. Let label be the StringValue of LabelIdentifier.
2. Let newLabelSet be the list-concatenation of labelSet and « label ».
3. Return ContainsUndefinedContinueTarget of LabelledItem with arguments iterationSet and newLabelSet.
LabelledItem : FunctionDeclaration
1. Return false.
TryStatement : try Block Catch
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of Catch with arguments iterationSet and « ».
TryStatement : try Block Finally
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of Finally with arguments iterationSet and « ».
TryStatement : try Block Catch Finally
1. If ContainsUndefinedContinueTarget of Block with arguments iterationSet and « » is true, return true.
2. If ContainsUndefinedContinueTarget of Catch with arguments iterationSet and « » is true, return true.
3. Return ContainsUndefinedContinueTarget of Finally with arguments iterationSet and « ».
Catch : catch ( CatchParameter ) Block
1. Return ContainsUndefinedContinueTarget of Block with arguments iterationSet and « ».
FunctionStatementList : [empty]
1. Return false.
ClassStaticBlockStatementList : [empty]
1. Return false.
ModuleItemList : ModuleItemList ModuleItem
1. Let hasUndefinedLabels be ContainsUndefinedContinueTarget of ModuleItemList with arguments iterationSet and « ».
2. If hasUndefinedLabels is true, return true.
3. Return ContainsUndefinedContinueTarget of ModuleItem with arguments iterationSet and « ».
ModuleItem :
ImportDeclaration
ExportDeclaration
1. Return false.

## 8.4 Function Name Inference(函数名推断)

### 8.3.1 Static Semantics: HasName

语法制导的操作 HasName 没有参数。 它在以下产生式上分段定义：

```
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. If IsFunctionDefinition of expr is false, return false.
3. Return HasName of expr.

FunctionExpression :
    function ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
    async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function ( FormalParameters ) { AsyncFunctionBody }
ArrowFunction :
    ArrowParameters => ConciseBody
AsyncArrowFunction :
    async AsyncArrowBindingIdentifier => AsyncConciseBody
    CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
ClassExpression :
    class ClassTail
1. Return false.

FunctionExpression :
    function BindingIdentifier ( FormalParameters ) { FunctionBody }
GeneratorExpression :
    function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
    async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
    async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
ClassExpression :
    class BindingIdentifier ClassTail
1. Return true.
```

### 8.3.2 Static Semantics: IsFunctionDefinition

语法制导的操作 IsFunctionDefinition 不带任何参数。 它在以下产生式上分段定义：

```
PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return IsFunctionDefinition of expr.
PrimaryExpression :
this
IdentifierReference
Literal
ArrayLiteral
ObjectLiteral
RegularExpressionLiteral
TemplateLiteral
MemberExpression :
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
new MemberExpression Arguments
MemberExpression . PrivateIdentifier
NewExpression :
new NewExpression
LeftHandSideExpression :
CallExpression
OptionalExpression
UpdateExpression :
LeftHandSideExpression ++
LeftHandSideExpression --
++ UnaryExpression
-- UnaryExpression
UnaryExpression :
delete UnaryExpression
void UnaryExpression
typeof UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression
AwaitExpression
ExponentiationExpression :
UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression
ShiftExpression :
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression
RelationalExpression :
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression instanceof ShiftExpression
RelationalExpression in ShiftExpression
PrivateIdentifier in ShiftExpression
EqualityExpression :
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
BitwiseANDExpression :
BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
BitwiseXORExpression ^ BitwiseANDExpression
BitwiseORExpression :
BitwiseORExpression | BitwiseXORExpression
LogicalANDExpression :
LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
LogicalORExpression || LogicalANDExpression
CoalesceExpression :
CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
YieldExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
LeftHandSideExpression &&= AssignmentExpression
LeftHandSideExpression ||= AssignmentExpression
LeftHandSideExpression ??= AssignmentExpression
Expression :
Expression , AssignmentExpression
1. Return false.
AssignmentExpression :
ArrowFunction
AsyncArrowFunction
FunctionExpression :
function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
GeneratorExpression :
function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorExpression :
async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionExpression :
async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
ClassExpression :
class BindingIdentifieropt ClassTail
1. Return true.
```

### 8.3.3 Static Semantics: IsAnonymousFunctionDefinition ( expr )

抽象操作 IsAnonymousFunctionDefinition 采用参数 expr（AssignmentExpression Parse Node 或 Initializer Parse Node）。 它确定其参数是否是不绑定名称的函数定义。 它在调用时执行以下步骤：

1. If IsFunctionDefinition of expr is false, return false.
2. Let hasName be HasName of expr.
3. If hasName is true, return false.
4. Return true.


### 8.3.4 Static Semantics: IsIdentifierRef

语法制导的操作 IsIdentifierRef 不接受任何参数。 它在以下产生式上分段定义：

```
PrimaryExpression : IdentifierReference
1. Return true.
PrimaryExpression :
this
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList
MemberExpression :
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
new MemberExpression Arguments
MemberExpression . PrivateIdentifier
NewExpression :
new NewExpression
LeftHandSideExpression :
CallExpression
OptionalExpression
1. Return false.
```

### 8.3.5 Runtime Semantics: NamedEvaluation

语法导向的操作nameDeveration采用参数name。它是在以下产品上分段定义的：

PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return the result of performing NamedEvaluation of expr with argument name.
ParenthesizedExpression : ( Expression )
1. Assert: IsAnonymousFunctionDefinition(Expression) is true.
2. Return the result of performing NamedEvaluation of Expression with argument name.
FunctionExpression : function ( FormalParameters ) { FunctionBody }
1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression with argument name.
GeneratorExpression : function * ( FormalParameters ) { GeneratorBody }
1. Return InstantiateGeneratorFunctionExpression of GeneratorExpression with argument name.
AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody }
1. Return InstantiateAsyncGeneratorFunctionExpression of AsyncGeneratorExpression with argument name.
AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody }
1. Return InstantiateAsyncFunctionExpression of AsyncFunctionExpression with argument name.
ArrowFunction : ArrowParameters => ConciseBody
1. Return InstantiateArrowFunctionExpression of ArrowFunction with argument name.
AsyncArrowFunction :
async AsyncArrowBindingIdentifier => AsyncConciseBody
CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. Return InstantiateAsyncArrowFunctionExpression of AsyncArrowFunction with argument name.
ClassExpression : class ClassTail
1. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and name.
2. ReturnIfAbrupt(value).
3. Set value.[[SourceText]] to the source text matched by ClassExpression.
4. Return value.

## 8.4 Contains

### 8.4.1 Static Semantics: Contains

语法制导的操作包含takes参数符号。

本规范中未在下面列出的每一个语法生成选项都隐含着以下包含的默认定义：

1. For each child node child of this Parse Node, do
    - If child is an instance of symbol, return true.
    - If child is an instance of a nonterminal, then
        - Let contained be the result of child Contains symbol.
        - If contained is true, return true.
2. Return false.

FunctionDeclaration :
function BindingIdentifier ( FormalParameters ) { FunctionBody }
function ( FormalParameters ) { FunctionBody }
FunctionExpression :
function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
GeneratorDeclaration :
function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
function * ( FormalParameters ) { GeneratorBody }
GeneratorExpression :
function * BindingIdentifieropt ( FormalParameters ) { GeneratorBody }
AsyncGeneratorDeclaration :
async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
async function * ( FormalParameters ) { AsyncGeneratorBody }
AsyncGeneratorExpression :
async function * BindingIdentifieropt ( FormalParameters ) { AsyncGeneratorBody }
AsyncFunctionDeclaration :
async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
async function ( FormalParameters ) { AsyncFunctionBody }
AsyncFunctionExpression :
async function BindingIdentifieropt ( FormalParameters ) { AsyncFunctionBody }
1. Return false.

>NOTE1 依赖于子结构的静态语义规则通常不研究函数定义。

ClassTail : ClassHeritageopt { ClassBody }
1. If symbol is ClassBody, return true.
2. If symbol is ClassHeritage, then
    - If ClassHeritage is present, return true; otherwise return false.
3. If ClassHeritage is present, then
    - If ClassHeritage Contains symbol is true, return true.
4. Return the result of ComputedPropertyContains of ClassBody with argument symbol.

>NOTE2 依赖于子结构的静态语义规则通常不研究类主体，但PropertyNames除外。

ClassStaticBlock : static { ClassStaticBlockBody }
1. Return false.

>NOTE3 依赖于子结构的静态语义规则通常不会查看静态初始化块。

ArrowFunction : ArrowParameters => ConciseBody
1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super or this, return false.
2. If ArrowParameters Contains symbol is true, return true.
3. Return ConciseBody Contains symbol.

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. Let formals be the ArrowFormalParameters that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return formals Contains symbol.

AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody
1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super, or this, return false.
2. Return AsyncConciseBody Contains symbol.

AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody
1. If symbol is not one of NewTarget, SuperProperty, SuperCall, super, or this, return false.
2. Let head be the AsyncArrowHead that is covered by CoverCallExpressionAndAsyncArrowHead.
3. If head Contains symbol is true, return true.
4. Return AsyncConciseBody Contains symbol.

>NOTE4 Contains 用于检测 ArrowFunction 或 AsyncArrowFunction 中的 new.target、this 和 super 使用情况。

PropertyDefinition : MethodDefinition
1. If symbol is MethodDefinition, return true.
2. Return the result of ComputedPropertyContains of MethodDefinition with argument symbol.

LiteralPropertyName : IdentifierName
1. Return false.

MemberExpression : MemberExpression . IdentifierName
1. If MemberExpression Contains symbol is true, return true.
2. Return false.

SuperProperty : super . IdentifierName
1. If symbol is the ReservedWord super, return true.
2. Return false.

CallExpression : CallExpression . IdentifierName
1. If CallExpression Contains symbol is true, return true.
2. Return false.

OptionalChain : ?. IdentifierName
1. Return false.

OptionalChain : OptionalChain . IdentifierName
1. If OptionalChain Contains symbol is true, return true.
2. Return false.

### 8.4.2 Static Semantics: ComputedPropertyContains

语法制导的操作ComputedPropertyContains接受参数symbol。它是在以下产品上分段定义的：

ClassElementName : PrivateIdentifier
PropertyName : LiteralPropertyName
1. Return false.
PropertyName : ComputedPropertyName
1. Return the result of ComputedPropertyName Contains symbol.
MethodDefinition :
ClassElementName ( UniqueFormalParameters ) { FunctionBody }
get ClassElementName ( ) { FunctionBody }
set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
ClassElementList : ClassElementList ClassElement
1. Let inList be ComputedPropertyContains of ClassElementList with argument symbol.
2. If inList is true, return true.
3. Return the result of ComputedPropertyContains of ClassElement with argument symbol.
ClassElement : ClassStaticBlock
1. Return false.
ClassElement : ;
1. Return false.
AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.
FieldDefinition : ClassElementName Initializeropt
1. Return the result of ComputedPropertyContains of ClassElementName with argument symbol.

## 8.5 Miscellaneous(杂项)

这些操作在整个规范中的多个地方使用。

### 8.5.1 Runtime Semantics: InstantiateFunctionObject(实例化函数对象)

语法导向的操作 InstantiateFunctionObject 接受参数 env 和 privateEnv。 它在以下产生式上分段定义：

FunctionDeclaration :
function BindingIdentifier ( FormalParameters ) { FunctionBody }
function ( FormalParameters ) { FunctionBody }
1. Return ? InstantiateOrdinaryFunctionObject of FunctionDeclaration with arguments env and privateEnv.
GeneratorDeclaration :
function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
function * ( FormalParameters ) { GeneratorBody }
1. Return ? InstantiateGeneratorFunctionObject of GeneratorDeclaration with arguments env and privateEnv.
AsyncGeneratorDeclaration :
async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
async function * ( FormalParameters ) { AsyncGeneratorBody }
1. Return ? InstantiateAsyncGeneratorFunctionObject of AsyncGeneratorDeclaration with arguments env and privateEnv.
AsyncFunctionDeclaration :
async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
async function ( FormalParameters ) { AsyncFunctionBody }
1. Return ? InstantiateAsyncFunctionObject of AsyncFunctionDeclaration with arguments env and privateEnv.

### 8.5.2 Runtime Semantics: BindingInitialization(绑定初始化)

语法制导的操作BindingInitialization接受value和environment。

>NOTE 为环境传递 undefined 以指示应该使用 PutValue 操作来分配初始化值。 var 语句和一些非严格函数的形式参数列表就是这种情况（参见 10.2.11）。 在这些情况下，在评估其初始化程序之前，会提升和预初始化词法绑定。

它在以下产生式上分段定义：

BindingIdentifier : Identifier
1. Let name be StringValue of Identifier.
2. Return ? InitializeBoundName(name, value, environment).
BindingIdentifier : yield
1. Return ? InitializeBoundName("yield", value, environment).
BindingIdentifier : await
1. Return ? InitializeBoundName("await", value, environment).
BindingPattern : ObjectBindingPattern
1. Perform ? RequireObjectCoercible(value).
2. Return the result of performing BindingInitialization of ObjectBindingPattern with arguments value and environment.
BindingPattern : ArrayBindingPattern
1. Let iteratorRecord be ? GetIterator(value).
2. Let result be IteratorBindingInitialization of ArrayBindingPattern with arguments iteratorRecord and environment.
3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
4. Return result.

ObjectBindingPattern : { }
1. Return NormalCompletion(empty).
ObjectBindingPattern :
{ BindingPropertyList }
{ BindingPropertyList , }
1. Perform ? PropertyBindingInitialization of BindingPropertyList with arguments value and environment.
2. Return NormalCompletion(empty).
ObjectBindingPattern : { BindingRestProperty }
1. Let excludedNames be a new empty List.
2. Return the result of performing RestBindingInitialization of BindingRestProperty with arguments value, environment, and excludedNames.
ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }
1. Let excludedNames be ? PropertyBindingInitialization of BindingPropertyList with arguments value and environment.
2. Return the result of performing RestBindingInitialization of BindingRestProperty with arguments value, environment, and excludedNames.

#### 8.5.2.1 InitializeBoundName ( name, value, environment )

抽象操作 InitializeBoundName 采用参数name（a String）、value和environment。 它在调用时执行以下步骤：

1. If environment is not undefined, then
    - Perform environment.InitializeBinding(name, value).
    - Return NormalCompletion(undefined).
2. Else,
    - Let lhs be ResolveBinding(name).
    - Return ? PutValue(lhs, value).

### 8.5.3 Runtime Semantics: IteratorBindingInitialization

语法指导的操作 IteratorBindingInitialization 接受参数 iteratorRecord 和environment。

>NOTE 当为environment传递undefined时，它表示应该使用PutValue操作来分配初始化值。非严格函数的形式参数列表就是这种情况。在这种情况下，形式参数绑定会预先初始化，以便处理多个参数同名的可能性。

It is defined piecewise over the following productions:

ArrayBindingPattern : [ ]
1. Return NormalCompletion(empty).
ArrayBindingPattern : [ Elision ]
1. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
ArrayBindingPattern : [ Elisionopt BindingRestElement ]
1. If Elision is present, then
a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
2. Return the result of performing IteratorBindingInitialization of BindingRestElement with arguments iteratorRecord and environment.
ArrayBindingPattern : [ BindingElementList , Elision ]
1. Perform ? IteratorBindingInitialization of BindingElementList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
ArrayBindingPattern : [ BindingElementList , Elisionopt BindingRestElement ]
1. Perform ? IteratorBindingInitialization of BindingElementList with arguments iteratorRecord and environment.
2. If Elision is present, then
a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
3. Return the result of performing IteratorBindingInitialization of BindingRestElement with arguments iteratorRecord and environment.
BindingElementList : BindingElementList , BindingElisionElement
1. Perform ? IteratorBindingInitialization of BindingElementList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorBindingInitialization of BindingElisionElement with arguments iteratorRecord and environment.
BindingElisionElement : Elision BindingElement
1. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with argument iteratorRecord.
2. Return the result of performing IteratorBindingInitialization of BindingElement with arguments iteratorRecord and environment.
SingleNameBinding : BindingIdentifier Initializeropt
1. Let bindingId be StringValue of BindingIdentifier.
2. Let lhs be ? ResolveBinding(bindingId, environment).
3. Let v be undefined.
4. If iteratorRecord.[[Done]] is false, then
a. Let next be IteratorStep(iteratorRecord).
b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(next).
d. If next is false, set iteratorRecord.[[Done]] to true.
e. Else,
i. Set v to IteratorValue(next).
ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(v).
5. If Initializer is present and v is undefined, then
a. If IsAnonymousFunctionDefinition(Initializer) is true, then
i. Set v to the result of performing NamedEvaluation of Initializer with argument bindingId.
b. Else,
i. Let defaultValue be the result of evaluating Initializer.
ii. Set v to ? GetValue(defaultValue).
6. If environment is undefined, return ? PutValue(lhs, v).
7. Return InitializeReferencedBinding(lhs, v).
BindingElement : BindingPattern Initializeropt
1. Let v be undefined.
2. If iteratorRecord.[[Done]] is false, then
a. Let next be IteratorStep(iteratorRecord).
b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(next).
d. If next is false, set iteratorRecord.[[Done]] to true.
e. Else,
i. Set v to IteratorValue(next).
ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(v).
3. If Initializer is present and v is undefined, then
a. Let defaultValue be the result of evaluating Initializer.
b. Set v to ? GetValue(defaultValue).
4. Return the result of performing BindingInitialization of BindingPattern with arguments v and environment.
BindingRestElement : ... BindingIdentifier
1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
2. Let A be ! ArrayCreate(0).
3. Let n be 0.
4. Repeat,
a. If iteratorRecord.[[Done]] is false, then
i. Let next be IteratorStep(iteratorRecord).
ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(next).
iv. If next is false, set iteratorRecord.[[Done]] to true.
b. If iteratorRecord.[[Done]] is true, then
i. If environment is undefined, return ? PutValue(lhs, A).
ii. Return InitializeReferencedBinding(lhs, A).
c. Let nextValue be IteratorValue(next).
d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
e. ReturnIfAbrupt(nextValue).
f. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), nextValue).
g. Set n to n + 1.
BindingRestElement : ... BindingPattern
1. Let A be ! ArrayCreate(0).
2. Let n be 0.
3. Repeat,
a. If iteratorRecord.[[Done]] is false, then
i. Let next be IteratorStep(iteratorRecord).
ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
iii. ReturnIfAbrupt(next).
iv. If next is false, set iteratorRecord.[[Done]] to true.
b. If iteratorRecord.[[Done]] is true, then
i. Return the result of performing BindingInitialization of BindingPattern with arguments A and environment.
c. Let nextValue be IteratorValue(next).
d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
e. ReturnIfAbrupt(nextValue).
f. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), nextValue).
g. Set n to n + 1.
FormalParameters : [empty]
1. Return NormalCompletion(empty).
FormalParameters : FormalParameterList , FunctionRestParameter
1. Perform ? IteratorBindingInitialization of FormalParameterList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorBindingInitialization of FunctionRestParameter with arguments iteratorRecord and environment.
FormalParameterList : FormalParameterList , FormalParameter
1. Perform ? IteratorBindingInitialization of FormalParameterList with arguments iteratorRecord and environment.
2. Return the result of performing IteratorBindingInitialization of FormalParameter with arguments iteratorRecord and environment.
ArrowParameters : BindingIdentifier
1. Let v be undefined.
2. Assert: iteratorRecord.[[Done]] is false.
3. Let next be IteratorStep(iteratorRecord).
4. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
5. ReturnIfAbrupt(next).
6. If next is false, set iteratorRecord.[[Done]] to true.
7. Else,
a. Set v to IteratorValue(next).
b. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(v).
8. Return the result of performing BindingInitialization of BindingIdentifier with arguments v and environment.
ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList
1. Let formals be the ArrowFormalParameters that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return IteratorBindingInitialization of formals with arguments iteratorRecord and environment.
AsyncArrowBindingIdentifier : BindingIdentifier
1. Let v be undefined.
2. Assert: iteratorRecord.[[Done]] is false.
3. Let next be IteratorStep(iteratorRecord).
4. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
5. ReturnIfAbrupt(next).
6. If next is false, set iteratorRecord.[[Done]] to true.
7. Else,
a. Set v to IteratorValue(next).
b. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
c. ReturnIfAbrupt(v).
8. Return the result of performing BindingInitialization of BindingIdentifier with arguments v and environment.


### 8.5.4 Static Semantics: AssignmentTargetType

语法制导的操作 AssignmentTargetType 不接受任何参数。 它在以下产生式上分段定义：

IdentifierReference : Identifier
1. If this IdentifierReference is contained in strict mode code and StringValue of Identifier is "eval" or "arguments", return invalid.
2. Return simple.
IdentifierReference :
yield
await
CallExpression :
CallExpression [ Expression ]
CallExpression . IdentifierName
CallExpression . PrivateIdentifier
MemberExpression :
MemberExpression [ Expression ]
MemberExpression . IdentifierName
SuperProperty
MemberExpression . PrivateIdentifier
1. Return simple.
PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList
1. Let expr be the ParenthesizedExpression that is covered by CoverParenthesizedExpressionAndArrowParameterList.
2. Return AssignmentTargetType of expr.
PrimaryExpression :
this
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
AsyncFunctionExpression
AsyncGeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CallExpression :
CoverCallExpressionAndAsyncArrowHead
SuperCall
ImportCall
CallExpression Arguments
CallExpression TemplateLiteral
NewExpression :
new NewExpression
MemberExpression :
MemberExpression TemplateLiteral
new MemberExpression Arguments
NewTarget :
new . target
ImportMeta :
import . meta
LeftHandSideExpression :
OptionalExpression
UpdateExpression :
LeftHandSideExpression ++
LeftHandSideExpression --
++ UnaryExpression
-- UnaryExpression
UnaryExpression :
delete UnaryExpression
void UnaryExpression
typeof UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression
AwaitExpression
ExponentiationExpression :
UpdateExpression ** ExponentiationExpression
MultiplicativeExpression :
MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
AdditiveExpression :
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression
ShiftExpression :
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression
RelationalExpression :
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression instanceof ShiftExpression
RelationalExpression in ShiftExpression
PrivateIdentifier in ShiftExpression
EqualityExpression :
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
BitwiseANDExpression :
BitwiseANDExpression & EqualityExpression
BitwiseXORExpression :
BitwiseXORExpression ^ BitwiseANDExpression
BitwiseORExpression :
BitwiseORExpression | BitwiseXORExpression
LogicalANDExpression :
LogicalANDExpression && BitwiseORExpression
LogicalORExpression :
LogicalORExpression || LogicalANDExpression
CoalesceExpression :
CoalesceExpressionHead ?? BitwiseORExpression
ConditionalExpression :
ShortCircuitExpression ? AssignmentExpression : AssignmentExpression
AssignmentExpression :
YieldExpression
ArrowFunction
AsyncArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression
LeftHandSideExpression &&= AssignmentExpression
LeftHandSideExpression ||= AssignmentExpression
LeftHandSideExpression ??= AssignmentExpression
Expression :
Expression , AssignmentExpression
1. Return invalid.

### 8.5.5 Static Semantics: PropName

语法制导的操作 PropName 不带任何参数。 它在以下产生式上分段定义：

PropertyDefinition : IdentifierReference
1. Return StringValue of IdentifierReference.
PropertyDefinition : ... AssignmentExpression
1. Return empty.
PropertyDefinition : PropertyName : AssignmentExpression
1. Return PropName of PropertyName.
LiteralPropertyName : IdentifierName
1. Return StringValue of IdentifierName.
LiteralPropertyName : StringLiteral
1. Return the SV of StringLiteral.
LiteralPropertyName : NumericLiteral
1. Let nbr be the NumericValue of NumericLiteral.
2. Return ! ToString(nbr).
ComputedPropertyName : [ AssignmentExpression ]
1. Return empty.
MethodDefinition :
ClassElementName ( UniqueFormalParameters ) { FunctionBody }
get ClassElementName ( ) { FunctionBody }
set ClassElementName ( PropertySetParameterList ) { FunctionBody }
1. Return PropName of ClassElementName.
GeneratorMethod : * ClassElementName ( UniqueFormalParameters ) { GeneratorBody }
1. Return PropName of ClassElementName.
AsyncGeneratorMethod : async * ClassElementName ( UniqueFormalParameters ) { AsyncGeneratorBody }
1. Return PropName of ClassElementName.
ClassElement : ClassStaticBlock
1. Return empty.
ClassElement : ;
1. Return empty.
AsyncMethod : async ClassElementName ( UniqueFormalParameters ) { AsyncFunctionBody }
1. Return PropName of ClassElementName.
FieldDefinition : ClassElementName Initializeropt
1. Return PropName of ClassElementName.
ClassElementName : PrivateIdentifier
1. Return empty.